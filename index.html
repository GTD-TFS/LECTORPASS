<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OCR Offline ‚Üí Excel</title>

  <!-- Cache busting b√°sico -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="manifest" href="manifest.webmanifest" />
  <script>
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');
  </script>

  <style>
    body { font-family: system-ui,sans-serif; background:#f4f4f4; color:#222; text-align:center; padding:2rem; }
    button { background:#007bff; color:#fff; border:none; border-radius:8px; padding:1rem 2rem; font-size:1.1rem; cursor:pointer; margin-top:1rem; }
    button:hover { background:#0056b3; }
    #log { white-space:pre-wrap; text-align:left; background:#fff; border:1px solid #ccc; border-radius:6px; padding:1rem; margin-top:2rem; max-height:340px; overflow:auto; }
  </style>
</head>
<body>
  <h1>Captura y exportaci√≥n offline</h1>
  <p>Pulsa para hacer una foto o elegir un documento.</p>

  <input id="fileInput" type="file" accept="image/*" capture="environment" hidden />
  <button id="captureBtn">üì∏xx Capturar / Elegir imagen</button>

  <div id="log"></div>

  <!-- Librer√≠as locales (ya las tienes en la ra√≠z) -->
  <script src="opencv.js"></script>
  <script src="exifr.min.js"></script>
  <script src="xlsx.full.min.js"></script>
  <script src="tesseract.min.js"></script>
  <script type="module" src="mrz.esm.js"></script>

  <script>
  // =============== LOG UI ===============
  const log = msg => { const el = document.getElementById('log'); el.textContent += msg + "\n"; console.log(msg); };
  document.getElementById('captureBtn').onclick = () => document.getElementById('fileInput').click();

  // =============== PARCHE CLAVE (solo HTML) ===============
  // Tesseract 4.1.1 pide *.traineddata.gz. T√∫ tienes *.traineddata.
  // Aqu√≠ interceptamos fetch: si pide .gz, cogemos el .traineddata plano, lo GZIPeamos en el navegador,
  // y devolvemos un Response .gz v√°lido. As√≠ NO tienes que cambiar ni renombrar archivos.
  (function installGzipShim(){
    const origFetch = window.fetch.bind(window);

    async function gzipArrayBuffer(ab){
      if (!('CompressionStream' in self)) {
        throw new Error('CompressionStream no soportado por este navegador. (Usa Chrome/Edge o sube spa/eng .traineddata.gz)');
      }
      const cs = new CompressionStream('gzip');
      const stream = new Response(new Blob([ab]).stream().pipeThrough(cs));
      const gzAB = await stream.arrayBuffer();
      return gzAB;
    }

    window.fetch = async function(resource, init){
      let url = typeof resource === 'string' ? resource : resource.url;

      // Si Tesseract pide .../spa.traineddata.gz o .../eng.traineddata.gz
      if (url.endsWith('.traineddata.gz')) {
        const plain = url.replace(/\.gz$/, ''); // mismo nombre, sin .gz (t√∫ lo tienes as√≠)
        // Si adem√°s lo busca en /tessdata/, redirige a ra√≠z
        const plainFixed = plain.includes('/tessdata/') ? plain.split('/tessdata/').pop() : plain;

        // Descarga el .traineddata plano y compr√≠melo a .gz en el navegador
        const res = await origFetch(plainFixed, init);
        if (!res.ok) return res; // si no existe, deja que falle para ver el 404 real
        const ab = await res.arrayBuffer();
        const gz = await gzipArrayBuffer(ab);
        return new Response(gz, {
          status: 200,
          headers: { 'Content-Type': 'application/octet-stream' } // cuerpo es gzip v√°lido
        });
      }

      // Si lo busca en /tessdata/ sin .gz, remapea a la ra√≠z
      if (url.includes('/tessdata/') && url.endsWith('.traineddata')) {
        const fixed = url.split('/tessdata/').pop();
        return origFetch(fixed, init);
      }

      return origFetch(resource, init);
    };
  })();

  // =============== OCR + Excel ===============
  document.getElementById('fileInput').onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    log("üì∏ Imagen seleccionada.");

    const imageURL = URL.createObjectURL(file);

    try {
      log("üîç Iniciando OCR (Tesseract 4.1.1)‚Ä¶");

      // MUY IMPORTANTE: usa worker y core locales para offline total
      const worker = await Tesseract.createWorker({
        workerPath: 'worker.min.js',
        corePath: 'tesseract-core-simd.js',
        langPath: '.',     // buscar√° ./spa.traineddata(.gz) y ./eng.traineddata(.gz)
        logger: m => { if (m.status) log(m.status + (m.progress!=null ? " " + Math.round(m.progress*100)+"%" : "")); }
      });

      await worker.loadLanguage('spa+eng');
      await worker.initialize('spa+eng');

      const { data: { text } } = await worker.recognize(imageURL);
      await worker.terminate();

      log("‚úÖ OCR completado.\n" + text.slice(0,500));

      // (Opcional) MRZ
      const mrzLines = text.split(/\n/).filter(l => l.includes('<'));
      if (mrzLines.length >= 2) {
        try {
          const { parse } = await import('./mrz.esm.js');
          const res = parse(mrzLines.join('\n'));
          log("üßæ MRZ OK:\n" + JSON.stringify(res.fields, null, 2));
        } catch (err) {
          log("‚ö†Ô∏è MRZ error: " + (err && err.message ? err.message : err));
        }
      }

      // Exportar Excel (marca simple en B1 para verificar)
      log("üìä Cargando plantilla Excel...");
      const buf = await (await fetch('1234.xlsx')).arrayBuffer();
      const wb  = XLSX.read(buf);
      const ws  = wb.Sheets[wb.SheetNames[0]];
      XLSX.utils.sheet_add_aoa(ws, [["OCR OK"]], { origin:"B1" });
      const out = XLSX.write(wb, { bookType:'xlsx', type:'array' });
      const blob = new Blob([out], { type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'salida.xlsx'; a.click();
      log("üíæ Excel exportado: salida.xlsx");

    } catch (err) {
      log("‚ùå Error OCR: " + (err && err.message ? err.message : err));
      log("Si el navegador no soporta CompressionStream, sube spa/eng como .traineddata.gz o usa Chrome/Edge.");
    }
  };
  </script>
</body>
</html>
