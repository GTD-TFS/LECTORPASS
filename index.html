<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OCR Offline ‚Üí Excel</title>

  <link rel="manifest" href="manifest.webmanifest" />

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(r=>console.log('SW activo:',r.scope));
    }
  </script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f4f4f4;
      color: #222;
      text-align: center;
      padding: 2rem;
    }
    button {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 1rem 2rem;
      font-size: 1.1rem;
      cursor: pointer;
      margin-top: 1rem;
    }
    button:hover { background: #0056b3; }
    #log {
      white-space: pre-wrap;
      text-align: left;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 2rem;
      max-height: 340px;
      overflow: auto;
    }
  </style>
</head>
<body>
  <h1>Captura y exportaci√≥n offline</h1>
  <p>Pulsa para hacer una foto o elegir un documento.</p>

  <input id="fileInput" type="file" accept="image/*" capture="environment" hidden />
  <button id="captureBtn">üì∏x Capturar / Elegir imagen</button>

  <div id="log"></div>

  <!-- Librer√≠as locales -->
  <script src="opencv.js"></script>
  <script src="exifr.min.js"></script>
  <script src="xlsx.full.min.js"></script>
  <script src="tesseract.min.js"></script>
  <script type="module" src="mrz.esm.js"></script>

  <script>
  const $log = document.getElementById('log');
  const log = msg => { $log.textContent += msg + "\\n"; console.log(msg); };

  document.getElementById('captureBtn').onclick = () =>
    document.getElementById('fileInput').click();

  // üîß Parche total para builds antiguas de Tesseract
  const originalFetch = window.fetch.bind(window);
  window.fetch = async (resource, init) => {
    let url = typeof resource === 'string' ? resource : resource.url;

    // Si intenta cargar modelo comprimido, devolvemos el plano
    if (url.endsWith('.traineddata.gz')) {
      const clean = url.replace(/\.gz$/, '');
      console.log('üîÑ Corrigiendo ruta modelo:', clean);
      return originalFetch(clean, init);
    }

    // Si busca dentro de /tessdata/, lo redirigimos a la ra√≠z
    if (url.includes('/tessdata/')) {
      const fixed = url.split('/tessdata/').pop();
      console.log('üîÑ Redirigiendo modelo desde tessdata/ ‚Üí', fixed);
      return originalFetch(fixed, init);
    }

    return originalFetch(resource, init);
  };

  const langPath = window.location.origin + window.location.pathname;

  async function ocrClassic(imageURL, lang) {
    log(`üîç Iniciando OCR (modo cl√°sico) con idioma: ${lang} ...`);
    const result = await Tesseract.recognize(
      imageURL,
      lang,
      {
        langPath,
        gzip: false,
        logger: m => {
          if (m && m.status) log(m.status + (m.progress != null ? " " + Math.round(m.progress*100)+"%" : ""));
        }
      }
    );
    return result;
  }

  async function doOCRWithFallbacks(imageURL) {
    const langs = ['spa+eng', 'eng', 'spa'];
    let lastErr = null;
    for (const lang of langs) {
      try {
        const res = await ocrClassic(imageURL, lang);
        if (res && res.data && res.data.text != null) {
          log("‚úÖ OCR completado con " + lang);
          return res.data.text;
        }
      } catch (err) {
        lastErr = err;
        log("‚ö†Ô∏è Falla OCR con " + lang + ": " + (err && err.message ? err.message : err));
      }
    }
    throw lastErr || new Error("OCR no disponible");
  }

  document.getElementById('fileInput').onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    log("üì∏ Imagen seleccionada.");

    const imageURL = URL.createObjectURL(file);

    try {
      const text = await doOCRWithFallbacks(imageURL);
      log("üìù Texto (primeros 500 chars):\\n" + text.slice(0,500));

      // ---------- MRZ ----------
      const mrzLines = text.split(/\\n/).filter(l => l.includes('<'));
      if (mrzLines.length >= 2) {
        log("üßæ MRZ detectada. Interpretando...");
        try {
          const { parse } = await import('./mrz.esm.js');
          const res = parse(mrzLines.join('\\n'));
          log("‚úÖ MRZ OK:\\n" + JSON.stringify(res.fields, null, 2));
        } catch (err) {
          log("‚ö†Ô∏è MRZ error: " + (err && err.message ? err.message : err));
        }
      } else {
        log("‚ÑπÔ∏è No se detect√≥ MRZ; sigo con OCR general.");
      }

      // ---------- Excel ----------
      log("üìä Cargando plantilla Excel...");
      const buf = await (await fetch('1234.xlsx')).arrayBuffer();
      const wb  = XLSX.read(buf);
      const ws  = wb.Sheets[wb.SheetNames[0]];
      XLSX.utils.sheet_add_aoa(ws, [["OCR OK"]], { origin:"B1" });
      const out = XLSX.write(wb, { bookType:'xlsx', type:'array' });
      const blob = new Blob([out], { type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'salida.xlsx'; a.click();
      log("üíæ Excel exportado: salida.xlsx");

    } catch (err) {
      log("‚ùå Error OCR: " + (err && err.message ? err.message : err));
      log("üëâ Revisa que spa.traineddata y eng.traineddata est√©n en la ra√≠z y accesibles.");
    }
  };
  </script>
</body>
</html>
