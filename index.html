<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OCR Offline ‚Üí Excel</title>

  <link rel="manifest" href="manifest.webmanifest" />
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>

  <style>
    body { font-family: system-ui, sans-serif; background:#f4f4f4; color:#222; text-align:center; padding:2rem; }
    button { background:#007bff; color:#fff; border:none; border-radius:8px; padding:1rem 2rem; font-size:1.1rem; cursor:pointer; margin-top:1rem; }
    button:hover { background:#0056b3; }
    #log { white-space:pre-wrap; text-align:left; background:#fff; border:1px solid #ccc; border-radius:6px; padding:1rem; margin-top:2rem; max-height:320px; overflow:auto; }
  </style>
</head>
<body>
  <h1>Captura y exportaci√≥n offline</h1>
  <p>Pulsa para hacer una foto o elegir un documento.</p>

  <input id="fileInput" type="file" accept="image/*" capture="environment" hidden />
  <button id="captureBtn">üì∏ Capturar / Elegir imagen</button>

  <div id="log"></div>

  <!-- Librer√≠as locales (mismo directorio) -->
  <script src="opencv.js"></script>
  <script src="exifr.min.js"></script>
  <script src="xlsx.full.min.js"></script>
  <script src="tesseract.min.js"></script>
  <!-- OJO: no insertar worker.min.js como <script>; lo carga internamente Tesseract -->
  <script src="tesseract-core-simd.js"></script>
  <!-- MRZ como m√≥dulo -->
  <script type="module" src="mrz.esm.js"></script>

  <script>
  const $log = document.getElementById('log');
  const log = (m) => { $log.textContent += m + "\n"; console.log(m); };

  document.getElementById('captureBtn').onclick = () => document.getElementById('fileInput').click();

  // --- Parche para usar .traineddata sin .gz SIN tocar tus archivos ---
  // 1) Forzamos a Tesseract v5 a NO esperar gzip
  // 2) Redirigimos cualquier petici√≥n *.traineddata.gz -> *.traineddata
  function installNoGzipShim() {
    // Monkeypatch de createWorker para inyectar gzip:false
    const origCreateWorker = Tesseract.createWorker;
    Tesseract.createWorker = function(opts={}, ...rest) {
      const patched = Object.assign({ gzip: false }, opts); // clave: gzip:false
      return origCreateWorker(patched, ...rest);
    };

    // Redirecci√≥n de fetch para nombres .gz -> sin .gz
    const origFetch = window.fetch.bind(window);
    window.fetch = async function(resource, init) {
      try {
        let url = (typeof resource === 'string') ? resource : resource.url;
        if (url.endsWith('.traineddata.gz')) {
          url = url.replace(/\.gz$/, ''); // apunta al archivo que t√∫ ya tienes
          resource = url;
        }
      } catch {}
      return origFetch(resource, init);
    };
  }

  installNoGzipShim();

  document.getElementById('fileInput').onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    log('üì∏ Imagen seleccionada.');

    const imageURL = URL.createObjectURL(file);

    try {
      log('üîç Cargando OCR (worker/wasm/modelos, sin .gz)‚Ä¶');

      // IMPORTANTE: no incluyas worker.min.js como <script>; Tesseract lo cargar√° √©l.
      const worker = await Tesseract.createWorker({
        workerPath: 'worker.min.js',         // ya lo tienes en la carpeta
        corePath:   'tesseract-core-simd.js',// ya lo tienes en la carpeta
        langPath:   '.',                     // buscar√° ./eng.traineddata y ./spa.traineddata
        logger: m => { if (m.status) log(m.status + (m.progress!=null ? ' ' + Math.round(m.progress*100)+'%' : '')); }
      });

      // Carga de idiomas locales SIN .gz gracias al shim
      await worker.loadLanguage('spa+eng');
      await worker.initialize('spa+eng');

      const { data: { text } } = await worker.recognize(imageURL);
      await worker.terminate();
      log('‚úÖ OCR completado.');

      // Intento MRZ si hay l√≠neas con '<'
      const mrzLines = text.split(/\n/).filter(l => l.includes('<'));
      if (mrzLines.length >= 2) {
        log('üßæ MRZ detectada. Interpretando‚Ä¶');
        try {
          const { parse } = await import('./mrz.esm.js');
          const res = parse(mrzLines.join('\n'));
          log('‚úÖ MRZ OK:\n' + JSON.stringify(res.fields, null, 2));
        } catch (err) { log('‚ö†Ô∏è MRZ error: ' + err); }
      } else {
        log('‚ÑπÔ∏è No se detect√≥ MRZ, se usar√° OCR general.');
      }

      // --- Ejemplo m√≠nimo: abrir plantilla y escribir algo para verificar exportaci√≥n ---
      const buf = await (await fetch('1234.xlsx')).arrayBuffer();
      const wb  = XLSX.read(buf);
      const ws  = wb.Sheets[wb.SheetNames[0]];
      // Marca de verificaci√≥n en B1 (NO toca tus nombres de campo; es solo para confirmar escritura)
      XLSX.utils.sheet_add_aoa(ws, [[ "OK OCR" ]], { origin: "B1" });

      const out = XLSX.write(wb, { bookType:'xlsx', type:'array' });
      const blob = new Blob([out], { type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'salida.xlsx'; a.click();
      log('üíæ Excel exportado: salida.xlsx');

    } catch (err) {
      log('‚ùå Error OCR: ' + (err && err.message ? err.message : err));
      log('Comprueba que est√°n en la carpeta: worker.min.js, tesseract-core-simd.js, tesseract-core-simd.wasm, eng.traineddata, spa.traineddata');
    }
  };
  </script>
</body>
</html>
